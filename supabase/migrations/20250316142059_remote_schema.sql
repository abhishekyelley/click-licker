create type "public"."permission_type" as enum ('links.insert', 'links.select', 'links.delete', 'invites.insert', 'invites.select', 'invites.delete', 'links.select.all', 'links.delete.all', 'invites.select.all', 'invites.delete.all', 'users.select', 'users.select.all');

create type "public"."role_type" as enum ('admin', 'link_maker');

create table "public"."role_permissions" (
    "id" bigint generated by default as identity not null,
    "role" role_type not null,
    "permission" permission_type not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."role_permissions" enable row level security;

create table "public"."user_roles" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid not null,
    "role" role_type not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."user_roles" enable row level security;

alter table "public"."invites" add column "role" role_type not null default 'link_maker'::role_type;

alter table "public"."links" add column "created_by" uuid;

CREATE UNIQUE INDEX role_permissions_pkey ON public.role_permissions USING btree (id);

CREATE UNIQUE INDEX unique_role_permission ON public.role_permissions USING btree (role, permission);

CREATE UNIQUE INDEX unique_user_role ON public.user_roles USING btree (user_id, role);

CREATE UNIQUE INDEX user_roles_pkey ON public.user_roles USING btree (id);

alter table "public"."role_permissions" add constraint "role_permissions_pkey" PRIMARY KEY using index "role_permissions_pkey";

alter table "public"."user_roles" add constraint "user_roles_pkey" PRIMARY KEY using index "user_roles_pkey";

alter table "public"."links" add constraint "links_created_by_fkey" FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE SET NULL not valid;

alter table "public"."links" validate constraint "links_created_by_fkey";

alter table "public"."role_permissions" add constraint "unique_role_permission" UNIQUE using index "unique_role_permission";

alter table "public"."user_roles" add constraint "unique_user_role" UNIQUE using index "unique_user_role";

alter table "public"."user_roles" add constraint "user_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."user_roles" validate constraint "user_roles_user_id_fkey";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.authorize(requested_permission permission_type)
 RETURNS boolean
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  bind_permissions int;
  user_role public.role_type;
begin
  -- Fetch user role once and store it to reduce number of calls
  select (auth.jwt() ->> 'user_role')::public.role_type into user_role;

  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE
AS $function$
  declare
    claims jsonb;
    user_role public.role_type;
  begin
    -- Fetch the user role in the user_roles table
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      -- Set the claim
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    -- Update the 'claims' object in the original event
    event := jsonb_set(event, '{claims}', claims);

    -- Return the modified or original event
    return event;
  end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  invite_count int;
  invitation_role public.role_type;
begin
  select count(*) into invite_count from public.invites i where i.email = new.email;
  if invite_count = 0 then
    RAISE EXCEPTION 'no invite found for email: %', new.email;
  end if;
  select role into invitation_role from public.invites i where i.email = new.email limit 1;
  delete from public.invites i where i.email = new.email;
  insert into public.users (id, full_name, email, username, avatar_url)
  values (new.id, new.raw_user_meta_data ->> 'full_name', new.email, new.raw_user_meta_data ->> 'username', new.raw_user_meta_data ->> 'avatar_url');
  insert into public.user_roles (user_id, role) values (new.id, invitation_role);
  return new;
end;
$function$
;

grant delete on table "public"."role_permissions" to "anon";

grant insert on table "public"."role_permissions" to "anon";

grant references on table "public"."role_permissions" to "anon";

grant select on table "public"."role_permissions" to "anon";

grant trigger on table "public"."role_permissions" to "anon";

grant truncate on table "public"."role_permissions" to "anon";

grant update on table "public"."role_permissions" to "anon";

grant delete on table "public"."role_permissions" to "authenticated";

grant insert on table "public"."role_permissions" to "authenticated";

grant references on table "public"."role_permissions" to "authenticated";

grant select on table "public"."role_permissions" to "authenticated";

grant trigger on table "public"."role_permissions" to "authenticated";

grant truncate on table "public"."role_permissions" to "authenticated";

grant update on table "public"."role_permissions" to "authenticated";

grant delete on table "public"."role_permissions" to "service_role";

grant insert on table "public"."role_permissions" to "service_role";

grant references on table "public"."role_permissions" to "service_role";

grant select on table "public"."role_permissions" to "service_role";

grant trigger on table "public"."role_permissions" to "service_role";

grant truncate on table "public"."role_permissions" to "service_role";

grant update on table "public"."role_permissions" to "service_role";

grant delete on table "public"."user_roles" to "service_role";

grant insert on table "public"."user_roles" to "service_role";

grant references on table "public"."user_roles" to "service_role";

grant select on table "public"."user_roles" to "service_role";

grant trigger on table "public"."user_roles" to "service_role";

grant truncate on table "public"."user_roles" to "service_role";

grant update on table "public"."user_roles" to "service_role";

grant delete on table "public"."user_roles" to "supabase_auth_admin";

grant insert on table "public"."user_roles" to "supabase_auth_admin";

grant references on table "public"."user_roles" to "supabase_auth_admin";

grant select on table "public"."user_roles" to "supabase_auth_admin";

grant trigger on table "public"."user_roles" to "supabase_auth_admin";

grant truncate on table "public"."user_roles" to "supabase_auth_admin";

grant update on table "public"."user_roles" to "supabase_auth_admin";

create policy "allow authorized to delete invites"
on "public"."invites"
as permissive
for delete
to authenticated
using (((( SELECT authorize('invites.delete'::permission_type) AS authorize) AND (auth.uid() = created_by)) OR ( SELECT authorize('invites.delete.all'::permission_type) AS authorize)));


create policy "allow authorized to insert"
on "public"."invites"
as permissive
for insert
to authenticated
with check (( SELECT authorize('invites.insert'::permission_type) AS authorize));


create policy "allow authorized to select invites"
on "public"."invites"
as permissive
for select
to authenticated
using (((( SELECT authorize('invites.select'::permission_type) AS authorize) AND (auth.uid() = created_by)) OR ( SELECT authorize('invites.select.all'::permission_type) AS authorize)));


create policy "allow authorized to create links"
on "public"."links"
as permissive
for insert
to authenticated
with check (( SELECT authorize('links.insert'::permission_type) AS authorize));


create policy "allow authorized to delete links"
on "public"."links"
as permissive
for delete
to authenticated
using (((( SELECT authorize('links.delete'::permission_type) AS authorize) AND (auth.uid() = created_by)) OR ( SELECT authorize('links.delete.all'::permission_type) AS authorize)));


create policy "allow authorized to select"
on "public"."links"
as permissive
for select
to authenticated
using (((( SELECT authorize('links.select'::permission_type) AS authorize) AND (auth.uid() = created_by)) OR ( SELECT authorize('links.select.all'::permission_type) AS authorize)));


create policy "Allow auth admin to read user roles"
on "public"."user_roles"
as permissive
for select
to supabase_auth_admin
using (true);


create policy "allow authorized to select users"
on "public"."users"
as permissive
for select
to authenticated
using (((( SELECT authorize('users.select'::permission_type) AS authorize) AND (auth.uid() = id)) OR ( SELECT authorize('users.select.all'::permission_type) AS authorize)));



